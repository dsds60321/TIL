## 단일 서버
![다운로드.png](..%2Fimg%2F%EB%8B%A4%EC%9A%B4%EB%A1%9C%EB%93%9C.png)
![단일서버2.png](..%2Fimg%2F%EB%8B%A8%EC%9D%BC%EC%84%9C%EB%B2%842.png)
* 웹 앱, 데이터베이스, 캐시 등 전부 한 서버에서 실행된다.
* 단일서버에 요청 흐름
  1. DNS에 질의하여 IP 반환
  2. IP주소로 HTTP 요청
  3. 요청 받은 웹서버 HTML 혹은 JSON 응답

## 데이터 베이스
![데이터베이스1.png](..%2Fimg%2F%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A41.png)
* 사용자가 늘어 웹 계층과 데이터 계층 서버를 분리하여 확장해 나가게된다.

### 어떤 데이터베이스를 사용할 것인가?
* RDBMS와 NOSQL 사이에서 고를 수 있다.
* NOSQL에 적합한 시스템
  1. 아주 낮은 응답 지연시간이 요구됨
  2. 데이터가 비정형이라 관계형이 아님
  3. 데이터를 직렬화하거나 역직렬화 할 수 있기만 하면 됨
  4. 아주 많은 양의 데이터를 저장할 필요가 있음

## 수직적 규모 확장 VS 수평적 규모 확장
* 수직적 규모 확장 (scale up) : 고사양 자원을 서버에 추가
* 수평적 규모 확장 (scale out) : 서버 추가
* 서버로 유입되는 양이 적을때는 수직적 확장이 선택이지만 몇가지 단점이 있다.
  1. 수직적 규모 확장에는 한계가 있다 (서버에 cpu나 메모리 증설에 한계)
  2. 자동 복구 혹은 다중화 방안이 없다 -> 서버에 장애가 발생시 서비스가 완전히 중단된다.
* 이러한 단점으로 대규모 서비스에는 수평적 규모 확장이 적절하다.

### 로드밸런서
![로드밸런스.png](..%2Fimg%2F%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%8A%A4.png)
  * 트래픽 부하를 고르게 분산하는 역활
  * 사용자는 로드밸런서의 공개 IP로 접속 -> 웹서버 클라이언트에 접속 처리 x -> 로드 밸런서 웹서버와 사설 IP (pirvate IP)로 통신

### 데이터베이스 다중화
* 서버 사이 master, slave 관계를 설정하고 데이터 원본은 주 서버, 사본은 부 서버에 저장하는 방법을 많이 사용한다.
* 쓰기 연산은 master, 부 데이터 베이스는 사본을 전달 받으며 읽기 연산만을 지원한다.
* 주로 읽기연산이 많으므로 부 데이터베이스가 주 데이터베이스 수보다 많다
* 데이터베이스를 다중화 장점
1. 더 나은 성능: 주 데이터베이스는 쓰기 부 데이터베이스에는 읽기 연산들이 병렬로 분산 되므로 성능이 좋아 진다.
2. 안정성: 자연재해 등의 이유로 일부가 파괴되어도 데이터를 지역적으로 여러 장소에 다중화 시켜 놓을수 있기에 보존된다.
3. 가용성: 데이터를 여러 지역에 복제해둠으로 서버에 장애가 발생되어도 다른서버에 있는 데이터를 가져와 계속 서비스할 수 있게 된다.
* DB 서버 하나가 다운되면 발생하는 일
1. slave 서버가 한 대 뿐인데 다운된 경우라면, 해당 slave서버가 새로운 master 서버의 역할을 할 것이며, 모든 db연산은 일시적으로 새로운 master 서버상에서 수행될 것이다. slave 서버가 여러 대인 경우, 읽기 연산은 나머지 slave 서버들로 분산되며, 새로운 slave 서버가 장애 서버를 대체할 것이다.
2. 만약 이전의 slave 서버에 보관된 데이터가 최신 상태가 아닌 경우 (서버 다운 전 동기화되지 않은 상태라면), 없는 데이터는 복구 스크립트(recovery script)를 돌려 추가해야 한다.
3. 다중 마스터(multi-masters), 원형 다중화(circular replication) 방식을 도입하면 위의 상황에 대처하는데 도움이 될 수 있다.<br>
![데이터 다중화.png](..%2Fimg%2F%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EB%8B%A4%EC%A4%91%ED%99%94.png)<br>
* 로드밸런서와 데이터베이스 다중화를 고려한 설계안
1. 사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다.
2. 사용자는 해당 IP 주소를 사용해 로드밸런서에 접속한다.
3. HTTP 요청은 서버 1이나 서버 2로 전달된다.
4. 웹 서버는 사용자의 데이터를 부 데이터베이스 서버에서 읽는다.
5. 웹 서버는 데이터 변경 연산은 주 데이터베이스로 전달한다. 데이터 추가, 삭제, 갱신 연산 등이 해당된다.
![디비다중화2.png](..%2Fimg%2F%EB%94%94%EB%B9%84%EB%8B%A4%EC%A4%91%ED%99%942.png)

## 캐시
### 캐시 계층
* 캐시 계층을 두면 성능 개선, 데이터베이스의 부하도 줄일 수 있다. 아래는 캐시 서버를 두는 방법 중 하나이다.
![캐시.png](..%2Fimg%2F%EC%BA%90%EC%8B%9C.png)
* 캐시 전략
1. 읽기 주도형 전략: 웹 서버는 캐시에 값이 저장되어 있는지를 본다 저장 되어 있다면 데이터를 클라이언트에게 반환, 없는 경우 데이터베이스 질의를 통해 데이터를 찾아 캐시에 저장한 뒤 반환 한다.
### 캐시 사용시 고려할 점
1. 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어남
2. 메모리 디비이기에 휘발성 메모리를 두어야한다. 영속성 데이터는 지속적 저장소에 두어야한다.
3. 만료 정책을 마련해두어야 한다. 너무 길 경우 원본과 차이가 날 가능성이 있으며 너무 짧을 경우 데이터베이스 조회가 자주 일어날것이다.
4. 원본과 값이 동일해야된다. 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션이 아닐 경우 일관성 유지에 어려움이 있을 수 있다.
5. 캐시 서버가 한대라면 단일장애지점(SPOF) 되어버릴 가능성이 있다.
6. 캐시 메모리가 너무 작을 경우 데이터가 자주 밀려나 성능이 떨어지게 된다. 이를 막을 방법은 캐시 메모리를 **과할당** 하는 것이다.
7. 데이터 방출 정책 : 주로 LRU(마지막 사용 시점이 오래된 데이터를 내보내는 정책)을 사용 LFU, FIFO같은 정책도 존재한다.

## CDN
* 정적 컨텐츠들에 캐싱을 위해 사용된다.
* CDN 동작
1. 사용자에 방문
2. CDN 서버의 캐시에 해당 파일이 없는 경우 원본 서버에 요청하여 파일을 가져온다.
3. 원본 파일을 CDN 서버에 반환한다. 응답의 HTTP 헤더에 파일이 얼마나 오래 캐시될 수 있는지 TTL값이 들어 있다.
4. CDN 서버는 파일을 캐시하고 사용자 A에게 반환한다. 이미지는 TTL에 명시된 시간이 끝날때까지 캐시된다.
5. 사용자 B가 같은 파일을 요청한다.
6. 만료되지 않은 파일에 대한 요청은 캐시를 통해 처리된다.
![cdn.png](..%2Fimg%2Fcdn.png)

### CDN 사용시 고려 사항
1. 비용: 데이터 전송 양에 따라 요금을 내기에 자주 사용되지 않은 콘텐츠는 캐싱하는것은 제외한다.
2. 만료시한 : 너무 짧을 경우 원본 서버에 빈번한 접속이 발생하므로 적당한 시간이 필요
3. 장애 대처 : CDN 자체가 죽을 경우 원 서버로 콘텐츠를 직접 가져오게 구성해야한다.
4. 콘텐츠 무효화: 아직 만료되지 않은 콘텐츠여도 아래 방법을 사용하면 CDN에서 제거할 수 있다.
   1. CDN 사업자가 제공하는 API를 이용한 콘텐츠 무효화
   2. 다른 버전을 서비스하도록 오브젝트 버저닝 ?v=2 와 같이 URL 변경

* CDN 캐시가 추가된 설계
1. 정적 콘텐츠 서비스 CDN을 사용
2. 캐시가 데이터베이스에 부하를 줄여준다.
![cdn2.png](..%2Fimg%2Fcdn2.png)

## 무상태 웹 계층
* 웹 계층을 수평적으로 확장 하는 방법 이를 위해서는 세션과 같은 상태 정보를 웹 계층에서 제거해야 한다. NOSQL RDBMS 같은 영속성 저장소에 보관하며 필요할 때 가져오도록 하는 것 이렇게 구성된 웹 계층을 무상태 웹 계층이라 부른다.

### 상태 정보 의존적인 아키텍쳐
* 상태 의존적인 아키텍쳐는 항상 같은 서버로가 인증을 거쳐야 한다. 로드밸런서가 이를 지원하기 위해 고정 세션(sticky session)을 지원하지만 로드밸런서에 부담을 주며 서버 장애를 처리하기에도 복잡해진다.
![무상태.png](..%2Fimg%2F%EB%AC%B4%EC%83%81%ED%83%9C.png)

### 무상태 아키텍쳐
* 이 구조에서는 사용자의 요청이 어느 웹서버로도 전달이 가능하다. 상태 정보는 웹 서버로부터 물리적으로 분리되어 있어 안정적이며 확장이 쉽다.
![무상태아키.png](..%2Fimg%2F%EB%AC%B4%EC%83%81%ED%83%9C%EC%95%84%ED%82%A4.png)

### 무상태 웹 계층을 포함한 설계
* 상태 정보를 보관하는 공유 저장소는 RDBMS NOSQL Redis 캐시시스템 어느거나 가능하다.
* 아래 그림에서는 NOSQL을 사용 NOSQL 사용
![무상태3.png](..%2Fimg%2F%EB%AC%B4%EC%83%81%ED%83%9C3.png)

## 데이터 센터
![데이터센터.png](..%2Fimg%2F%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%84%BC%ED%84%B0.png)
* 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내되는데, 통상 이 절차를 지리적 라우팅이라고 부른다.
* 데이터 센터 중 하나에 심각한 자애가 발생하면 모든 트래픽은 장애가 없는 데이터 센터로 전송된다.
### 다중 데이터센터를 만들기 위해서 고려해야 할 조건
1. 트래픽 우회: 올바른 데이터 센터로 트래픽을 보내는 효과적인 방법을 찾아야 합니다.
2. 데이터 동기화: 데이터 센터마다 별도의 데이터베이스를 다중화
3. 테스트와 배포: 여러 위치에서 애플리케이션을 테스트 해보고, 자동화 배포가 모든 데이터 센터에 동일하게 설치

## 메세지 큐
* 메세지 큐는 메세지의 무손실, 즉 메세지 큐에 일단 보관된 메세지는 소비자가 꺼낼 떄까지 안전히 보관된다는 특성을 보장하는 비동기 통신을 지원하는 컴포넌트이다. Publish/Producer는 메세지 큐에 발행한다. 큐에는 보통 Consumer/Subscribe가 메세지를 꺼내서 동작을 수행한다.
<br>메세지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.

![메세지큐.png](..%2Fimg%2F%EB%A9%94%EC%84%B8%EC%A7%80%ED%81%90.png)


## 로그, 메트릭 그리고 자동화
* 비지니스의 규모가 커지면 로그, 매트릭, 자동화 도구에 필수적으로 투자해야한다
1. 로그: 에러 모니터링을 위해. 로그를 단일 서비스로 모아주는 도구를 사용할 수도 있음
2. 메트릭: 유용한 정보, 시스템의 현 상태를 파악하기 위해
3. 자동화: 생산성과 안정성을 높이기 위해
![로그메트릭.png](..%2Fimg%2F%EB%A1%9C%EA%B7%B8%EB%A9%94%ED%8A%B8%EB%A6%AD.png)

## 데이터베이스의 규모 확장
* 저장할 데이터가 많아지면 데이터베이스에 대한 부하도 증가한다. 이 때도 애플리케이션 서버처럼 스케일 업, 스케일 아웃 두 가지 방법이 존재한다.
![데이터베이스규모확장.png](..%2Fimg%2F%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EA%B7%9C%EB%AA%A8%ED%99%95%EC%9E%A5.png)
  데이터베이스에도 수직적 확장보다는 수평적 확장이 더 적절하다. 수평적 확장에 대표적으로는 샤딩이 있다. 샤딩은 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술을 말한다.

샤딩 전략을 구현할 때 중요한 것은 샤딩 키 이다. 샤딩 키에 따라서 한 곳으로만 부하가 집중될 수 있고 여러 곳으로 적절히 잘 분산될 수도 있다.

* 샤딩을 위해서 고려해야 할 조건
1. 데이터의 재 샤딩
   1. 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때
   2. 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때
2. 유명 인사: 핫스팟 키 문제라고도 부르는데, 특정 샤드에 쿼리가 집중되어 서버에 과부하가 걸리는 문제
3. 조인과 비정규화
   일단 하나의 데이터베이스를 여러 샤드 서버로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다. <br>이를 해결하는 한 가지 방법은 데이터베이스를 비정규화하여 하나의 테이블에서 쿼리가 수행될 수 있도록 하는 것이다.
![데이터베이스수평적확장.png](..%2Fimg%2F%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%88%98%ED%8F%89%EC%A0%81%ED%99%95%EC%9E%A5.png)
![데이터페이스수평적2.png](..%2Fimg%2F%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%88%98%ED%8F%89%EC%A0%812.png)