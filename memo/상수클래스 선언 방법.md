# 상수 클래스를 생성 방법
### 안티 패턴으로는 interface를 사용하는 경우가 있다.
* 인터페이스는 변수를 등록할 때 자동으로 public static final이 붙게됩니다. <br>
따라서 상수처럼 어디에서나 접근할 수 있습니다. 인터페이스는 하나의 클래스에 여러 개의 인터페이스를 Implement 할 수 있는데,<br>
Constant Interface를 Implement 할 경우, 인터페이스의 클래스 명을 네임스페이스로 붙이지 않고 바로 사용할 수 이런 편리성 때문에 인터페이스를 이용하는 코드도 종종 보이게 됩니다.
### 인터페이스가 안티패턴인 이유
1. 인터페이스 오용: 인터페이스는 타입을 정의하는 목적으로 사용 됩니다. 어떤 객체에 동작을 정의하는데 목적이 있는 타입이라 상수를 정의하는것은 원칙에 어긋납니다.
2. 이름 공간 오염: 상수 인터페이스내 동일한 이름의 상수를 가지고 있고 두 인터페이스를 모두 구현하는 클래스에서는 어떤 상수를 사용하는지 모호해지게 됩니다.
3. API 오용 : 클래스가 상수 인터페이스를 구현하게 되면 상수들이 클래스의 공개 API의 일부가 되어 클래스가 제공하는 기능과 관련 없는 정보를 외부에 노출하는 결과를 가져옵니다.
### 상수 클래스 선언하는 방법
1. 불변성 유지: final 클래스는 불변성을 유지하는데 도움이 됩니다. final 클래스로 만들어진 객체는 한 번 생성되면 그 상태를 변경할 수 없습니다. 이는 멀티 스레드 환경에서 특히 유용합니다.
2. 보안: 클래스를 final로 선언하면, 다른 사람이 이 클래스를 확장하여 기능을 변경하거나 악용하는 것을 방지할 수 있습니다.
3. 설계 결정 보호: 다른 클래스에서 상속 받지 못하게하여 설계자가 의도한 대로 클래스가 사용되도록 보장합니다.

* 생성자를 private로 선언하여 외부에서 인스턴스 생성하는것을 막습니다.
* 이렇게 하면, Constants 클래스는 인스턴스화할 수 없으며, 상수 CONSTANT_NAME은 Constants.CONSTANT_NAME처럼 접근할 수 있습니다. 이 방법은 상수를 안전하게 캡슐화하고 코드의 가독성을 향상시키는 데 도움이 됩니다.
~~~java
public final class Constants {
    public static final String CONSTANT = "contant";
    
    // 이 클래스는 인스턴스화되지 않아야 함
    private Constants() {
        throw new UnsupportedOperationException("This is a utility class and cannot be instantiated");
    }
}
~~~

